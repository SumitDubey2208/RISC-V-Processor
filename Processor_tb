class mips_transaction extends uvm_sequence_item;
  rand bit [31:0] instruction;
  rand bit [31:0] data;
  rand bit [9:0]  addr;
  
  `uvm_object_utils_begin(mips_transaction)
    `uvm_field_int(instruction, UVM_ALL_ON)
    `uvm_field_int(data, UVM_ALL_ON)
    `uvm_field_int(addr, UVM_ALL_ON)
  `uvm_object_utils_end
  
  function new(string name = "mips_transaction");
    super.new(name);
  endfunction
endclass

class mips_sequencer extends uvm_sequencer#(mips_transaction);
  `uvm_component_utils(mips_sequencer)
  
  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction
endclass

class mips_driver extends uvm_driver#(mips_transaction);
  `uvm_component_utils(mips_driver)
  virtual mips_if vif;
  
  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    if(!uvm_config_db#(virtual mips_if)::get(this, "", "vif", vif))
      `uvm_fatal("NOVIF", "Virtual interface not found")
  endfunction
  
  virtual task run_phase(uvm_phase phase);
    forever begin
      seq_item_port.get_next_item(req);
      @(posedge vif.clk1);
      seq_item_port.item_done();
    end
  endtask
endclass

class mips_monitor extends uvm_monitor;
  `uvm_component_utils(mips_monitor)
  virtual mips_if vif;
  uvm_analysis_port#(mips_transaction) item_collected_port;
  mips_transaction trans_collected;
  
  function new(string name, uvm_component parent);
    super.new(name, parent);
    item_collected_port = new("item_collected_port", this);
  endfunction
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    if(!uvm_config_db#(virtual mips_if)::get(this, "", "vif", vif))
      `uvm_fatal("NOVIF", "Virtual interface not found")
  endfunction
  
  virtual task run_phase(uvm_phase phase);
    forever begin
      @(posedge vif.clk1);
      trans_collected = mips_transaction::type_id::create("trans_collected");
      item_collected_port.write(trans_collected);
    end
  endtask
endclass

class mips_agent extends uvm_agent;
  `uvm_component_utils(mips_agent)
  mips_driver driver;
  mips_sequencer sequencer;
  mips_monitor monitor;
  
  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    driver = mips_driver::type_id::create("driver", this);
    sequencer = mips_sequencer::type_id::create("sequencer", this);
    monitor = mips_monitor::type_id::create("monitor", this);
  endfunction
  
  virtual function void connect_phase(uvm_phase phase);
    driver.seq_item_port.connect(sequencer.seq_item_port);
  endfunction
endclass

class mips_scoreboard extends uvm_scoreboard;
  `uvm_component_utils(mips_scoreboard)
  uvm_analysis_imp#(mips_transaction, mips_scoreboard) item_collected_export;
  int passed, failed;
  
  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    item_collected_export = new("item_collected_export", this);
  endfunction
  
  virtual function void write(mips_transaction trans);
    `uvm_info(get_type_name(), $sformatf("Transaction received"), UVM_LOW)
    passed++;
  endfunction
  
  virtual function void report_phase(uvm_phase phase);
    `uvm_info(get_type_name(), $sformatf("Passed: %0d, Failed: %0d", passed, failed), UVM_LOW)
  endfunction
endclass

class mips_env extends uvm_env;
  `uvm_component_utils(mips_env)
  mips_agent agent;
  mips_scoreboard scoreboard;
  
  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    agent = mips_agent::type_id::create("agent", this);
    scoreboard = mips_scoreboard::type_id::create("scoreboard", this);
  endfunction
  
  virtual function void connect_phase(uvm_phase phase);
    agent.monitor.item_collected_port.connect(scoreboard.item_collected_export);
  endfunction
endclass

class basic_sequence extends uvm_sequence#(mips_transaction);
  `uvm_object_utils(basic_sequence)
  
  function new(string name = "basic_sequence");
    super.new(name);
  endfunction
  
  virtual task body();
    mips_transaction trans;
    
    trans = mips_transaction::type_id::create("trans");
    start_item(trans);
    trans.instruction = {6'b000000, 5'd1, 5'd2, 5'd3, 11'd0};
    finish_item(trans);
    
    trans = mips_transaction::type_id::create("trans");
    start_item(trans);
    trans.instruction = {6'b001010, 5'd1, 5'd4, 16'd10};
    finish_item(trans);
    
    trans = mips_transaction::type_id::create("trans");
    start_item(trans);
    trans.instruction = {6'b111111, 26'd0};
    finish_item(trans);
  endtask
endclass

class mips_test extends uvm_test;
  `uvm_component_utils(mips_test)
  mips_env env;
  basic_sequence seq;
  
  function new(string name, uvm_component parent);
    super.new(name, parent);
  endfunction
  
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    env = mips_env::type_id::create("env", this);
  endfunction
  
  virtual task run_phase(uvm_phase phase);
    phase.raise_objection(this);
    seq = basic_sequence::type_id::create("seq");
    seq.start(env.agent.sequencer);
    #1000;
    phase.drop_objection(this);
  endtask
endclass

interface mips_if(input logic clk1, clk2);
  logic reset;
endinterface

module top;
  import uvm_pkg::*;
  `include "uvm_macros.svh"
  
  logic clk1, clk2;
  
  initial begin
    clk1 = 0;
    forever #5 clk1 = ~clk1;
  end
  
  initial begin
    clk2 = 0;
    forever #10 clk2 = ~clk2;
  end
  
  mips_if vif(clk1, clk2);
  
  MIPS_32 dut(.clk1(clk1), .clk2(clk2));
  
  initial begin
    uvm_config_db#(virtual mips_if)::set(null, "*", "vif", vif);
    run_test("mips_test");
  end
  
  initial begin
    $dumpfile("dump.vcd");
    $dumpvars(0, top);
  end
endmodule
