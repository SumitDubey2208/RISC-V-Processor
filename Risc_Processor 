// Code your design here
module MIPS_32(clk1,clk2);
input clk1,clk2;
  //pipelining registers 
  reg [2:0] ID_EX_T,EX_MEM_T,MEM_WB_T;
  reg [31:0] PC,IF_ID_IR,IF_ID_NPC;
  reg [31:0] ID_EX_NPC,ID_EX_IR,ID_EX_A,ID_EX_B,ID_EX_IMM;
  reg [31:0] EX_MEM_IR,EX_MEM_ALU,EX_MEM_B;
  reg        EX_MEM_COND;
  reg [31:0] MEM_WB_IR,MEM_WB_LMD,MEM_WB_ALU;
  // memory and registerbank
  reg [31:0] REG [0:31];//32*32
  reg [31:0] MEM [0:1023];//1024*32 memory
  //parameters for opcodes
  parameter ADD=6'b000000,SUB=6'b000001,AND=6'b000010,OR=6'b000011,SLT=6'b000100,MUL=6'b000101,XOR=6'b000110,XNOR=6'b000111,LW=6'b001000,SW=6'b001001,
  ADDI=6'b001010,SUBI=6'b001011,SLTI=6'b001100,BNEQZ=6'b001101,BEQZ=6'b001110,HLT=6'b111111;
  //parameter for mux control
 parameter RR_ALU=3'b000,RM_ALU=3'b001,LOAD=3'b010,STORE=3'b011,BRANCH=3'b100,HALT=3'b101;
  //REG FOR BLOCKING INTRUCTIUON
  reg HAULTED;
  reg TAKEN_BRANCH;
  
  //========================================    INSTRUCTION FETCH  ==========================================================================
  
  always@(posedge clk1)
    if (HAULTED ==0)//NO HAULT STATEMENT
      begin
        if(((EX_MEM_IR[31:26]==BEQZ) && (EX_MEM_COND==1))||((EX_MEM_IR[31:26]==BNEQZ) && (EX_MEM_COND==0)))//FOR BRANCHING INSTRUCTION
          begin
            
            IF_ID_IR <= #2 MEM[EX_MEM_ALU];
            PC <= #2 EX_MEM_ALU + 1;
            IF_ID_NPC <= #2 EX_MEM_ALU + 1;
            TAKEN_BRANCH <= #2 1'b1;
          end
        else                    //FOR NORMAL INSTRUCTION  
         
          begin
            IF_ID_IR <= #2 MEM[PC];
          PC <= #2 PC + 1;
         IF_ID_NPC <= #2 PC + 1;
          end
      end
  //===========================================   END      ==================================================================================
  
  //=========================================== INSTRUCTION DECODE ==========================================================================
  always@(posedge clk2)
    if( HAULTED == 0)
    begin
           //--------------------------- rs
      if(IF_ID_IR[25:21]==5'b00000) 
        ID_EX_A <= #2 0;
      else
        ID_EX_A <= #2 REG[IF_ID_IR[25:21]];
           //-----------------------------rt
      if(IF_ID_IR[20:16]==5'b00000) 
        ID_EX_B <= #2 0;
      else
        ID_EX_B <= #2 REG[IF_ID_IR[20:16]];
           //----------------------------passing registers
        ID_EX_NPC <= #2 IF_ID_NPC;
        ID_EX_IR  <= #2 IF_ID_IR;
           //----------------------------sign extension
      ID_EX_IMM <= #2 {{16{IF_ID_IR[15]}},{IF_ID_IR[15:0]}};
      
           //-----------------------------mux control
      case(IF_ID_IR[31:26])
        ADD,SUB,AND,OR,SLT,MUL,XOR,XNOR : ID_EX_T <= #2 RR_ALU;
          ADDI,SUBI,SLTI:       ID_EX_T <= #2 RM_ALU;
          LW:                   ID_EX_T <= #2 LOAD;
          SW:                   ID_EX_T <= #2 STORE;
          BNEQZ,BEQZ:           ID_EX_T <= #2 BRANCH;
          HLT:                  ID_EX_T <= #2 HALT;
          default:              ID_EX_T <= #2 HALT;
          endcase
        
    end
  //===============================================  END  ==================================================================================
  
  //==============================================  INSTRUCTION EXECUTION  =================================================================
  always@(posedge clk1)
    if(HAULTED == 0)
      begin
        //Â ---------------------PASSING THE REGISTER VALUES
        EX_MEM_T <= #2 ID_EX_T;
        EX_MEM_IR <= #2 ID_EX_IR;
        TAKEN_BRANCH <= #2 0;
        
        
        case (ID_EX_T)
          RR_ALU:begin
            case( ID_EX_IR[31:26])
              ADD :        EX_MEM_ALU <= #2 ID_EX_A  + ID_EX_B;
              SUB :        EX_MEM_ALU <= #2 ID_EX_A  + ID_EX_B;
              AND :        EX_MEM_ALU <= #2 ID_EX_A  & ID_EX_B;
              OR  :        EX_MEM_ALU <= #2 ID_EX_A  | ID_EX_B;
              SLT :        EX_MEM_ALU <= #2 ID_EX_A  < ID_EX_B;
              MUL :        EX_MEM_ALU <= #2 ID_EX_A  * ID_EX_B;
              XOR :        EX_MEM_ALU <= #2 ID_EX_A  ^ ID_EX_B;
              XNOR :       EX_MEM_ALU <= #2 ~(ID_EX_A  ^ ID_EX_B);
              default :    EX_MEM_ALU <= #2 32'hxxxxxxxx;
            endcase
          end
          RM_ALU:begin
            case(ID_EX_IR[31:26])
              ADDI :       EX_MEM_ALU <= #2 ID_EX_A  + ID_EX_IMM;
              SUBI :       EX_MEM_ALU <= #2 ID_EX_A  - ID_EX_IMM;
              SLTI :       EX_MEM_ALU <= #2 ID_EX_A  < ID_EX_IMM;
              default:     EX_MEM_ALU <= #2 32'hxxxxxxxx;
            endcase
          end
          
          STORE,LOAD:
            begin
              EX_MEM_ALU <= #2 ID_EX_A + ID_EX_IMM;
              EX_MEM_B   <= #2 ID_EX_B;
            end
          BRANCH:
            begin
               case(ID_EX_IR[31:26])
              BEQZ:   EX_MEM_ALU <= #2 ID_EX_IMM +ID_EX_NPC;
              BNEQZ:  EX_MEM_ALU <= #2 ID_EX_IMM+ID_EX_NPC;
              default:     EX_MEM_ALU <= #2 32'hxxxxxxxx;
              endcase
              if( ID_EX_A == 32'h00000000)
                EX_MEM_COND <= 1'b1;
              else
                 EX_MEM_COND <= 1'b0;
             
            end
       //HLT: HAULTED  <= #2 1'b1; 
        endcase
            
      end 
  //=============================================. END. ==============================================================================================
        
  //=============================================.  MEMORY.  =========================================================================================
        always@(posedge clk2)
          if(HAULTED == 0)
            begin
              MEM_WB_T <= #2 EX_MEM_T;
              MEM_WB_IR <= #2 EX_MEM_IR;
              
              case (EX_MEM_T)
                RR_ALU,RM_ALU:  MEM_WB_ALU <= #2 EX_MEM_ALU ;
                LOAD :          MEM_WB_LMD <= #2 MEM[ EX_MEM_ALU];
                STORE :         begin
                  if (TAKEN_BRANCH ==0)
                    MEM[ EX_MEM_ALU] <=  #2 EX_MEM_B;
                end
              endcase
            end 
  //=============================================. END   ============================================================================================
          
  //================================================   WRITE BACK ===================================================================================
          
          always@(posedge clk1)
            if(TAKEN_BRANCH == 0)
              begin
              case (MEM_WB_T)
                RR_ALU : REG[ MEM_WB_IR[15:11]] <= #2 MEM_WB_ALU ;
                RM_ALU : REG[ MEM_WB_IR[20:16]] <= #2 MEM_WB_ALU ;
                LOAD :   REG[ MEM_WB_IR[20:16]] <= #2 MEM_WB_LMD ;
                HALT :   HAULTED  <= #2 1'b1;
              endcase
        end
     
endmodule
                